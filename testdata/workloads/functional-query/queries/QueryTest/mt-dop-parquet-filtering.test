# This tests parquet dictionary filtering. It is mirrored without mt_dop
# in parquet-filtering.test. Since the two rely on counting
# the number of row groups filtered, differing parallelism changes
# the counts seen in the output.
# TODO: Fix test execution to allow aggregation of these counts
# so that the results do not depend on the number of threads.
====
---- QUERY
# id: All values pass
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where id < 10000;
---- RESULTS
7300
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# id: Some values pass
# Filters 2/3 row groups
select count(*) from functional_parquet.alltypes where mod(id, 10000) < 20;
---- RESULTS
20
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 2.*
====
---- QUERY
# id: No values pass
# Filters 3/3 row groups
select count(*) from functional_parquet.alltypes where mod(id,10000) = 7301;
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 3.*
====
---- QUERY
# tinyint_col: All values pass
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where tinyint_col < 10;
---- RESULTS
7300
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# tinyint_col: No values pass
# Filters 3/3 row groups
select count(*) from functional_parquet.alltypes where mod(tinyint_col,50) > 10;
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 3.*
====
---- QUERY
# smallint_col: All values pass
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where smallint_col < 10
---- RESULTS
7300
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# smallint_col: No values pass
# Filters 3/3 row groups
select count(*) from functional_parquet.alltypes where mod(smallint_col,50) > 10;
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 3.*
====
---- QUERY
# int_col: All values pass
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where int_col < 10
---- RESULTS
7300
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# int_col: No values pass
# Filters 3/3 row groups
select count(*) from functional_parquet.alltypes where mod(int_col, 50) > 10;
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 3.*
====
---- QUERY
# bigint_col: All values pass
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where bigint_col < 100
---- RESULTS
7300
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# bigint_col: No values pass
# Filters 3/3 row groups
select count(*) from functional_parquet.alltypes where mod(bigint_col, 500) > 100;
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 3.*
====
---- QUERY
# float_col: All values pass
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where float_col < 10
---- RESULTS
7300
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# float_col: No values pass
# Filters 3/3 row groups
select count(*) from functional_parquet.alltypes where mod(float_col, 100) > 10;
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 3.*
====
---- QUERY
# double_col: All values pass
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where double_col < 100
---- RESULTS
7300
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# double_col: No values pass
# Filters 3/3 row groups
select count(*) from functional_parquet.alltypes where mod(double_col, 100) > 100;
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 3.*
====
---- QUERY
# date_string_col: All values pass
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where date_string_col like '%/%/%';
---- RESULTS
7300
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# date_string_col: Half of the values pass
# Filters 1/3 row groups
select count(*) from functional_parquet.alltypes where date_string_col like '%/10';
---- RESULTS
3650
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 1.*
====
---- QUERY
# date_string_col: No values pass
# Filters 3/3 row groups
select count(*) from functional_parquet.alltypes where date_string_col = '01/01/11';
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 3.*
====
---- QUERY
# string_col: All values pass
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where length(string_col) = 1 ;
---- RESULTS
7300
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# string_col: No values pass
# Filters 3/3 row groups
select count(*) from functional_parquet.alltypes where string_col = '10';
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 3.*
====
---- QUERY
# timestamp_col: All values pass
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where timestamp_col >= '2009-01-01 00:00:00';
---- RESULTS
7300
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# timestamp_col: No values pass
# Note: dictionary filtering currently does not work on timestamps
# Filters 0/3 row groups
select count(*) from functional_parquet.alltypes where timestamp_col = '2009-01-01 00:00:01';
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 3.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# TPC-H lineitem.l_orderkey has high cardinality (1500000)
# It always uses mixed encoding (PLAIN_DICTIONARY + PLAIN)
# Verify that no dictionary filtering is used even for a predicate
# that eliminates all rows.
select count(*) from tpch_parquet.lineitem where l_orderkey = 50;
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 1.*
row_regex: .*NumDictFilteredRowGroups: 0.*
====
---- QUERY
# Verify dictionary filtering on top level of a schema with nested
# data.
select count(*) from tpch_nested_parquet.customer where c_mktsegment = 'COMEDY';
---- RESULTS
0
---- RUNTIME_PROFILE
row_regex: .*NumRowGroups: 1.*
row_regex: .*NumDictFilteredRowGroups: 1.*
====
